// Platform-aware EventEmitter import (resolved by webpack alias/replacement)
import EventEmitter from 'events';
import { v7 as uuidv7 } from 'uuid';
// Version injected by webpack DefinePlugin for bundled builds, fallback to import for dev
// Conditional import based on CSP compliance needs
import {
  validatePayload as validateGeneratedPayload,
  validateMessageEnvelope as validateGeneratedMessageEnvelope,
} from '../../generated/validators.js';
import {
  validatePayload as validateBrowserPayload,
  validateMessageEnvelope as validateBrowserMessageEnvelope,
} from '../platform/browser/validators.js';

import CONSTANTS, {
  SPEC_VERSION,
  SCHEMA_REF,
  ErrorCategory,
  LegacyEvents,
  EVENTS,
  InboundEvents,
  ALLOWED_ACTIONS,
} from './constants.js';
import { validateSDKConfig, setSmartDefaults } from '../validation/config-validator.js';
import { BuildTargetUtils } from './build-targets.js';
import { OptaveError, makeStructuredError } from './errors.js';
import { loadNodeWebSocket } from '../platform/node/websocket-loader.js';
import { enforceWebSocketScheme } from './security-guards.js';

const SDK_VERSION = typeof __SDK_VERSION__ !== 'undefined' ? __SDK_VERSION__ : '0.0.0-dev';

// Build-time environment detection using webpack DefinePlugin
const getBuildContext = () => {
  const buildTarget = typeof __WEBPACK_BUILD_TARGET__ !== 'undefined' ? __WEBPACK_BUILD_TARGET__ : 'unknown';
  return {
    isBrowser: BuildTargetUtils.isBrowser(buildTarget),
    isServer: BuildTargetUtils.isServer(buildTarget),
    buildTarget
  };
};

const isBrowserEnv = () => {
  const context = getBuildContext();
  // Use build target for webpack builds, fallback to runtime detection for dev
  return context.buildTarget !== 'unknown'
    ? context.isBrowser
    : (typeof window !== 'undefined' && typeof window.WebSocket !== 'undefined');
};

// Module-level warning flags for Step 5 dual event emission
let warnedMessageEventOnce = false;
let warnedErrorStringOnce = false;

/**
 * Optave JavaScript SDK for WebSocket-based AI service integration
 * @typedef {import('./types.js').Opts} Opts
 * @typedef {import('./types.js').Logger} Logger
 * @typedef {import('../../generated/connection-config.js').AuthTransport} AuthTransport
 */
class OptaveJavaScriptSDK extends EventEmitter {
  options = {};
  wss = null;

  // The default payload. The payload provided by the user is merged "on top" of these objects
  static defaultPayload = {
    session: {
      sessionId: '', // custom - lasts for the duration of a chat session or a call
      channel: {
        browser: '',
        deviceInfo: '', // e.g. "iOS/18.2, iPhone15,3"
        deviceType: '',
        language: '',
        location: '', // e.g. "45.42,-75.69"
        medium: 'chat', // options: "chat", "voice", "email"
        metadata: [], // custom metadata
        section: '', // e.g. "cart", "product_page"
      },
      interface: {
        appVersion: '', // custom
        category: '', // e.g. "crm", "app", "auto", "widget"
        language: '', // the language from the crm agent
        name: '', // e.g. "salesforce", "zendesk"
        type: '', // e.g. "custom_components", "marketplace", "channel"
      },
    },
    request: {
      requestId: '',
      attributes: {
        content: '',
        instruction: '',
        variant: 'A',
      },
      connections: {
        journeyId: '',
        parentId: '', // in v2, this was called "trace_parent_ID"
        threadId: '', // this ID should remain unique across all the requests related to the same ticket/case/conversation
      },
      context: {
        // generated by optave
        caseId: '', // advanced mode
        departmentId: '', // advanced mode
        operatorId: '', // advanced mode
        organizationId: '',
        userId: '', // advanced mode
      },
      reference: {
        // optionally generated by client, used for analytics
        ids: [{ name: '', value: '' }],
        labels: [],
        tags: [],
      },
      resources: {
        codes: [
          {
            id: '', // optional for tracking/mapping
            label: '', // optional, helps for display/templating - e.g. "Order Number"
            type: '', // e.g., "order_number", "booking_reference", "ticket_code", etc.
            value: '', // e.g. "ORD-56789"
          },
        ],
        links: [
          {
            expires_at: '', //optional - e.g. "2025-08-06T00:00:00Z"
            html: false, //optional
            id: '', //optional
            label: '', //optional - e.g. "Click here to pay"
            type: '', // e.g., "payment_link", etc.
            url: '', // e.g. "https://checkout.stripe.com/pay/cs_test..."
          },
        ],
        offers: [], // in v2, this was called "offering_details"
      },
      // Items below should only be sent if they are directly related to the request
      // There are two ways of sending it:
      // 1. Reference a previously created object (advanced mode)
      // Format: { id: "", name: "", type: "", timestamp: "" }, (mandatory: id)
      // 2. Send the object itself (risk: may exceed the payload size limit) - easy mode
      scope: {
        accounts: [],
        appointments: [],
        assets: [],
        bookings: [],
        cases: [],
        conversations: [], // in v2, this was called "user_perspective" - populate when actually sending conversation data
        documents: [],
        events: [],
        interactions: [],
        items: [],
        locations: [],
        operators: [],
        orders: [],
        organizations: [],
        persons: [],
        policies: [],
        products: [{ id: '' }],
        properties: [],
        services: [],
        subscriptions: [],
        tickets: [],
        transactions: [],
        users: [],
        // Missing something? We can add it for you, please contact our sales team.
      },
      settings: {
        disableBrowsing: false,
        disableSearch: false,
        disableSources: false,
        disableStream: true,
        disableTools: false,
        maxResponseLength: 0,
        overrideInterfaceLanguage: '',
        overrideOutputLanguage: '', // replaces the channel language
      },
      // Advanced mode:
      a2a: [
        { id: '', name: '', type: '' }, // e.g. { id: "bot_55", name: "Bot 55", type: "chatbot" }
      ],
      cursor: {
        since: '', // e.g. "2024-01-15T10:30:00.000Z"
        until: '', // e.g. "2024-01-15T11:00:00.000Z"
      },
    },
  };

  /**
   * Static cleanup method for shared/global resources (e.g., JSDOM contexts)
   * This should be called after all SDK instances have been cleaned up individually
   */
  static cleanup() {
    // Clear module-level warning flags
    warnedMessageEventOnce = false;
    warnedErrorStringOnce = false;

    // Additional static cleanup can be added here as needed
    // This is primarily for test environments using JSDOM or similar contexts
  }

  /**
   * Creates a new OptaveJavaScriptSDK instance
   * @param {Opts} options - Configuration options extending GeneratedClientConfig with SDK-specific settings
   */
  constructor(options) {
    super();

    // Apply smart defaults and validate configuration
    this.options = { ...options };
    setSmartDefaults(this.options);

    // Auto-detect CSP compliance mode based on build target
    if (this.options.cspSafe === undefined) {
      const context = getBuildContext();
      // Only server-esm should use full AJV validation by default
      // All other builds (browser-esm, browser-umd, server-umd) should use CSP-safe mode
      if (context.buildTarget === 'server-esm' || context.buildTarget === 'server') {
        this.options.cspSafe = false; // Server ESM uses full AJV validation
      } else if (context.buildTarget === 'server-umd' || context.buildTarget === 'browser-esm' ||
                 context.buildTarget === 'browser-umd' || context.isBrowser || isBrowserEnv()) {
        this.options.cspSafe = true; // All browser builds and server UMD use CSP-safe mode
      }
      // If buildTarget is unknown/undefined, let user explicitly set cspSafe or use default undefined
    }

    const validation = validateSDKConfig(this.options);

    // Handle validation errors - throw for errors, warn for warnings
    if (!validation.isValid) {
      const errorMessages = validation.errors.map(e => e.message).join('; ');
      throw new Error(`[Optave SDK] Configuration errors: ${errorMessages}`);
    }

    // Log warnings using the configured logger
    validation.warnings.forEach(warning => {
      (this.options?.logger?.warn || console.warn)(`[Optave SDK] ${warning.message}`);
    });

    // WebSocket scheme validation for UMD/browser builds (Salesforce Locker compatibility)
    // SECURITY: This validation is critical for Salesforce Lightning security - must not be removed by tree-shaking
    const buildTarget =
      typeof __WEBPACK_BUILD_TARGET__ !== 'undefined' ? __WEBPACK_BUILD_TARGET__ : 'unknown';
    try {
      // Use canonical security guard - single source of truth for WebSocket validation
      enforceWebSocketScheme(this.options.websocketUrl, buildTarget, this.options);
    } catch (securityError) {
      // Re-throw security errors immediately - this prevents minification from removing the try/catch
      throw securityError;
    }

    // Initialize WebSocket implementation
    // Use build-aware WebSocket detection to avoid window references in server builds
    const context = getBuildContext();
    this.WebSocketImpl = this.options.WebSocketImpl;

    if (!this.WebSocketImpl && context.isBrowser) {
      // Browser builds: check global WebSocket then window.WebSocket
      this.WebSocketImpl = (typeof WebSocket !== 'undefined' ? WebSocket : undefined) ||
                          (typeof window !== 'undefined' && window.WebSocket ? window.WebSocket : undefined);
    } else if (!this.WebSocketImpl && context.isServer) {
      // Server builds: only check global WebSocket, no window references
      this.WebSocketImpl = typeof WebSocket !== 'undefined' ? WebSocket : undefined;
    }
    // Note: WebSocket implementation loading moved to _ensureWebSocketImpl() for async handling

    // Holds pending correlation promises: correlationId -> { resolve, reject, timer, action }
    this._pending = new Map();

    // Note: _activeTimeouts removed as we now use queueMicrotask() instead of setTimeout()
    // which doesn't require tracking IDs for cleanup

    // Deprecation tracking
    this._deprecatedKeys = new Set();
    this._silenceDeprecations =
      typeof process !== 'undefined' && process?.env?.OPTAVE_SDK_SILENCE_DEPRECATIONS === '1';

    // Set up CSP-safe validation functions
    if (this.options.cspSafe) {
      this._validatePayload = validateBrowserPayload;
      this._validateMessageEnvelope = validateBrowserMessageEnvelope;
    } else {
      this._validatePayload = validateGeneratedPayload;
      this._validateMessageEnvelope = validateGeneratedMessageEnvelope;
    }
  }

  // Async WebSocket implementation loader for ES module compatibility
  async _ensureWebSocketImpl() {
    if (this.WebSocketImpl) return this.WebSocketImpl;

    // Initialize WebSocket implementation with build-aware logic
    const context = getBuildContext();
    this.WebSocketImpl = this.options.WebSocketImpl;

    if (!this.WebSocketImpl && context.isBrowser) {
      // Browser builds: check global WebSocket then window.WebSocket
      this.WebSocketImpl = (typeof WebSocket !== 'undefined' ? WebSocket : undefined) ||
                          (typeof window !== 'undefined' && window.WebSocket ? window.WebSocket : undefined);
    } else if (!this.WebSocketImpl && context.isServer) {
      // Server builds: only check global WebSocket, no window references
      this.WebSocketImpl = typeof WebSocket !== 'undefined' ? WebSocket : undefined;
    }

    // Only attempt to load 'ws' module in Node.js environments if still not found
    if (!this.WebSocketImpl) {
      // Use webpack DefinePlugin to completely eliminate Node.js WebSocket imports in browser builds
      if (context.isBrowser) {
        // Browser build - use browser WebSocket implementation
        this.WebSocketImpl = typeof WebSocket !== 'undefined' ? WebSocket : null;
      } else if (context.isServer) {
        // Server build - load Node.js WebSocket implementation using webpack-friendly pattern
        this.WebSocketImpl = await this.loadNodeWebSocket();
      }
    }

    return this.WebSocketImpl;
  }

  // WebSocket loader for Node.js environments only
  async loadNodeWebSocket() {
    const context = getBuildContext();

    // Browser builds should never reach this code path, but double-check
    if (context.isBrowser) {
      return null;
    }

    // For fallback compatibility in dev environments, check browser globals
    if (context.buildTarget === 'unknown' && (
      typeof window !== 'undefined' ||
      typeof document !== 'undefined' ||
      typeof navigator !== 'undefined' ||
      typeof location !== 'undefined'
    )) {
      return null;
    }

    // Additional check for Node.js-specific globals
    if (typeof process === 'undefined' || !process.versions || !process.versions.node) {
      return null;
    }

    // Use static import instead of dynamic import for UMD builds
    return await loadNodeWebSocket();
  }

  // Public static helpers for consumers (optional export pattern)
  static getSdkVersion() {
    return SDK_VERSION;
  }
  static getSpecVersion() {
    return SPEC_VERSION;
  }
  static getSchemaRef() {
    return SCHEMA_REF;
  }
  static get CONSTANTS() {
    return CONSTANTS;
  }

  // Static exports for constants (moved from named exports to avoid mixed export issues)
  static get LegacyEvents() {
    return LegacyEvents;
  }
  static get InboundEvents() {
    return InboundEvents;
  }

  setSessionId(id) {
    this.sessionId = id;
    return this; // allow chaining if you like
  }

  getSessionId() {
    return this.sessionId || '';
  }

  validate(jsonObject) {
    // Backward compatible boolean return; wraps validator (CSP-safe or AJV)
    const r = this._validatePayload(jsonObject);
    return r.valid;
  }

  validateEnvelope(envelope) {
    const r = this._validateMessageEnvelope(envelope);
    return r.valid;
  }

  // Validates action-specific required fields
  validateRequiredFields(params, action) {
    const errors = [];

    // Common required fields for all actions
    if (!params.request?.connections?.threadId) {
      errors.push('request.connections.threadId is required');
    }

    // Action-specific required fields
    switch (action) {
      case 'adjust':
        if (!params.request?.attributes?.content) {
          errors.push('request.attributes.content is required for adjust');
        }
        if (!params.request?.attributes?.instruction) {
          errors.push('request.attributes.instruction is required for adjust');
        }
        if (!params.request?.connections?.parentId) {
          errors.push('request.connections.parentId is required for adjust');
        }
        if (
          !params.request?.scope?.conversations ||
          !Array.isArray(params.request.scope.conversations) ||
          params.request.scope.conversations.length === 0
        ) {
          errors.push(
            'request.scope.conversations is required for adjust and must be a non-empty array'
          );
        }
        break;

      case 'elevate':
        if (!params.request?.attributes?.content) {
          errors.push('request.attributes.content is required for elevate');
        }
        if (!params.request?.connections?.parentId) {
          errors.push('request.connections.parentId is required for elevate');
        }
        if (
          !params.request?.scope?.conversations ||
          !Array.isArray(params.request.scope.conversations) ||
          params.request.scope.conversations.length === 0
        ) {
          errors.push(
            'request.scope.conversations is required for elevate and must be a non-empty array'
          );
        }
        break;

      case 'translate':
      case 'summarize':
      case 'insights':
        if (
          !params.request?.scope?.conversations ||
          !Array.isArray(params.request.scope.conversations) ||
          params.request.scope.conversations.length === 0
        ) {
          errors.push(
            `request.scope.conversations is required for ${action} and must be a non-empty array`
          );
        }
        break;

      case 'recommend':
        if (
          !params.request?.resources?.offers ||
          !Array.isArray(params.request.resources.offers) ||
          params.request.resources.offers.length === 0
        ) {
          errors.push(
            'request.resources.offers is required for recommend and must be a non-empty array'
          );
        }
        if (
          !params.request?.scope?.conversations ||
          !Array.isArray(params.request.scope.conversations) ||
          params.request.scope.conversations.length === 0
        ) {
          errors.push(
            'request.scope.conversations is required for recommend and must be a non-empty array'
          );
        }
        break;

      case 'customerinteraction': // legacy lowercase for backward compatibility
      case 'customerInteraction': // current camelCase
      case 'interaction':
        if (
          !params.request?.scope?.conversations ||
          !Array.isArray(params.request.scope.conversations) ||
          params.request.scope.conversations.length === 0
        ) {
          errors.push(
            `request.scope.conversations is required for ${action} and must be a non-empty array`
          );
        }
        break;

      case 'reception':
        // Reception has no additional required fields beyond common ones.
        break;

      default:
        // For unknown actions, just check common required fields
        break;
    }

    return {
      isValid: errors.length === 0,
      errors: errors,
    };
  }

  async authenticate() {
    // Browser-targeted builds should not use client credentials for security
    // Server builds (ESM and UMD) can authenticate with client credentials
    // Use the SDK's own build flags rather than environment variables for accuracy
    const buildTarget =
      typeof __WEBPACK_BUILD_TARGET__ !== 'undefined' ? __WEBPACK_BUILD_TARGET__ : 'unknown';
    const isBrowserTargetedBuild = BuildTargetUtils.isBrowser(buildTarget);

    if (isBrowserTargetedBuild) {
      this.handleError(
        ErrorCategory.AUTHENTICATION,
        'UNSUPPORTED_IN_BROWSER',
        'authenticate() is not available in browsers. Use options.tokenProvider() to obtain a short-lived WebSocket token from your backend.'
      );
      return null;
    }
    let params = {
      grant_type: 'client_credentials',
    };

    if (!this.options.authenticationUrl) {
      this.handleError(
        ErrorCategory.AUTHENTICATION,
        'INVALID_AUTHENTICATION_URL',
        'Empty or invalid authentication URL'
      );
      return null;
    }

    if (!this.options.clientId) {
      this.handleError(
        ErrorCategory.AUTHENTICATION,
        'INVALID_CLIENT_ID',
        'Empty or invalid client ID'
      );
      return null;
    }

    params.client_id = this.options.clientId;
    // Never set clientSecret in browser/mobile/Electron renderers
    // Client secrets must only be used in secure server-side environments
    params.client_secret = this.options.clientSecret;

    const paramsString = new URLSearchParams(params).toString();

    // Automatically append /token to authenticationUrl if not present
    // This allows clients to provide base OAuth2 URL (e.g., /auth/oauth2)
    // without needing to remember the /token suffix
    let authUrl = this.options.authenticationUrl;
    if (!authUrl.endsWith('/token')) {
      authUrl = authUrl.endsWith('/') ? authUrl + 'token' : authUrl + '/token';
    }

    const url = `${authUrl}?${paramsString}`;
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
    });

    const responseJson = await response.json();

    if (!response.ok) {
      this.handleError(
        ErrorCategory.AUTHENTICATION,
        'INVALID_AUTHENTICATION_RESPONSE',
        this.formatAuthenticationError(response, responseJson.error, 'token endpoint').message,
        responseJson.error
      );
      return null;
    }

    return responseJson.access_token;
  }

  async openConnection(bearerToken) {
    if (!this.options.websocketUrl) {
      (this.options?.logger?.error || console.error)(
        '[Optave SDK] openConnection aborted: missing websocketUrl'
      );
      this.handleError(
        ErrorCategory.WEBSOCKET,
        'INVALID_WEBSOCKET_URL',
        this.formatWebSocketError(new Error('Invalid WebSocket URL configuration'), {
          url: this.options.websocketUrl,
        }).message,
        this.options.websocketUrl
      );
      return;
    }

    const getToken = async () => {
      if (typeof bearerToken === 'string' && bearerToken.length > 0) return bearerToken;
      if (typeof this.options.tokenProvider === 'function') {
        try {
          return await this.options.tokenProvider();
        } catch (e) {
          this.handleError(
            ErrorCategory.AUTHENTICATION,
            'TOKEN_PROVIDER_FAILED',
            this.formatTokenProviderError(e).message,
            e
          );
          return null;
        }
      }
      return null;
    };

    const token = await getToken();

    // Ensure WebSocket implementation is available
    await this._ensureWebSocketImpl();

    if (!this.WebSocketImpl) {
      this.handleError(
        ErrorCategory.WEBSOCKET,
        'NO_WEBSOCKET_IMPL',
        this.formatWebSocketError(new Error('No WebSocket implementation available'), {
          environment: typeof window !== 'undefined' ? 'browser' : 'node',
        }).message
      );
      return;
    }

    if (!token && this.options.authRequired !== false) {
      this.handleError(
        ErrorCategory.AUTHENTICATION,
        'MISSING_TOKEN',
        'No WebSocket token available. Provide options.tokenProvider() or set options.tokenUrl.'
      );
      return;
    }

    const qp = new URLSearchParams();
    if (this.sessionId) qp.set('OptaveTraceChatSessionId', this.sessionId);

    try {
      if (this.options.authTransport === 'subprotocol') {
        // Recommended: token via Sec-WebSocket-Protocol to avoid URL leaks
        const protocols = token ? ['optave-v1', token] : ['optave-v1'];
        this.wss = new this.WebSocketImpl(
          qp.toString()
            ? `${this.options.websocketUrl}?${qp.toString()}`
            : this.options.websocketUrl,
          protocols
        );
      } else {
        // Fallback: token in query string (avoid if possible)
        if (token) {
          // For WebSocket query parameters, use raw token without Bearer prefix
          // The Bearer prefix is for HTTP headers, not WebSocket query parameters
          const val = token.replace(/^Bearer\s+/i, '');
          qp.set('Authorization', val);
        }
        this.wss = new this.WebSocketImpl(
          qp.toString()
            ? `${this.options.websocketUrl}?${qp.toString()}`
            : this.options.websocketUrl
        );
        if (token) {
          this._warnOnce(
            '_warnedQueryToken',
            '[Optave SDK] Passing auth token in WebSocket URL query is discouraged. Prefer authTransport="subprotocol".'
          );
        }
      }
    } catch (error) {
      (this.options?.logger?.error || console.error)(
        '[Optave SDK] WebSocket constructor threw',
        error
      );
      this.handleError(
        ErrorCategory.WEBSOCKET,
        'WEBSOCKET_ERROR',
        this.formatWebSocketError(error, { url: this.options.websocketUrl }).message,
        error
      );
      return;
    }
    // Return a promise that resolves when the connection is established
    return new Promise((resolve, reject) => {
      // Set up connection timeout to prevent hanging
      const connectionTimeout = setTimeout(() => {
        const timeoutMs = this.options.connectionTimeoutMs || 30000;
        const errorMessage = this.formatWebSocketError(new Error('Connection timeout'), {
          timeout: timeoutMs,
          url: this.options.websocketUrl,
        }).message;

        // CRITICAL: Close the WebSocket to prevent zombie connections
        // Without this, the WebSocket continues attempting to connect in the background
        // causing resource leaks, race conditions, and connection conflicts on retry attempts
        if (this.wss) {
          // Clear event handlers first to prevent them from firing during close
          this.wss.onopen = null;
          this.wss.onmessage = null;
          this.wss.onclose = null;
          this.wss.onerror = null;

          // Close the connection
          try {
            this.wss.close();
          } catch (e) {
            // Ignore errors if WebSocket is in invalid state
          }

          // Mark as no active connection
          this.wss = null;
        }

        this.handleError(ErrorCategory.WEBSOCKET, 'CONNECTION_TIMEOUT', errorMessage);
        reject({
          category: ErrorCategory.WEBSOCKET,
          code: 'CONNECTION_TIMEOUT',
          message: errorMessage,
          details: null,
        });
      }, this.options.connectionTimeoutMs || 30000);

      this.wss.onopen = event => {
        clearTimeout(connectionTimeout);
        this.emit('open', event);
        resolve(event);
      };

      this.wss.onmessage = event => {
        this._handleInbound(event.data);
      };

      this.wss.onclose = event => {
        clearTimeout(connectionTimeout);
        this.emit('close', event);
        //
        // CRITICAL: Race condition prevention for promise handling
        // This pattern fixes race conditions where timeout timers compete with WebSocket events
        // The _handled flag ensures promises are only resolved/rejected once
        //
        // Reject all pending promises when connection closes
        for (const [correlationId, entry] of this._pending.entries()) {
          if (entry.timer) {
            clearTimeout(entry.timer);
          }
          // Mark entry as handled to prevent timeout from firing
          entry._handled = true;
          entry.reject({
            category: ErrorCategory.WEBSOCKET,
            code: 'CONNECTION_CLOSED',
            message: `WebSocket connection closed: ${event.reason || 'Connection lost'}`,
            details: { code: event.code, reason: event.reason, correlationId },
            correlationId,
          });
        }
        this._pending.clear();
        this.wss = null;
      };

      this.wss.onerror = event => {
        clearTimeout(connectionTimeout);
        //
        // CRITICAL: Enhanced error message handling and race condition prevention
        // This pattern fixes issues where test warnings revealed:
        // 1. Mock WebSocket error events not properly propagating error messages
        // 2. Race conditions between error handling and timeout timers
        // 3. Double promise resolution/rejection bugs
        //
        // Create error object - handle both native events and Error objects
        const errorMessage =
          event.message ||
          (event instanceof Error ? event.message : null) ||
          (typeof event === 'object' && event.error && event.error.message) ||
          'WebSocket connection failed';

        const errObj = {
          category: ErrorCategory.WEBSOCKET,
          code: 'CONNECTION_ERROR',
          message: errorMessage,
          details: { originalError: event },
        };

        // Reject all pending promises when WebSocket error occurs
        for (const [correlationId, entry] of this._pending.entries()) {
          if (entry.timer) {
            clearTimeout(entry.timer);
          }
          // Mark entry as handled to prevent timeout from firing
          entry._handled = true;
          entry.reject({
            ...errObj,
            details: { ...errObj.details, correlationId },
            correlationId,
          });
        }
        this._pending.clear();

        // Emit error event for general error handling
        this.emit('error', errObj);

        // Reject the openConnection promise
        reject(errObj);
      };
    });
  }

  // ---- Inbound Routing & Warning Utilities ----
  _warnOnce(flagName, message) {
    if (this[flagName]) return;
    this[flagName] = true;
    (this.options?.logger?.warn || console.warn)(message);
  }

  // Deprecation helper (one-time per runtime per key)
  deprecate(key, message) {
    if (this._silenceDeprecations) return;
    if (this._deprecatedKeys.has(key)) return;
    this._deprecatedKeys.add(key);
    (this.options?.logger?.warn || console.warn)(message);
  }

  _handleInbound(rawPayload) {
    let parsed;

    try {
      parsed = typeof rawPayload === 'string' ? JSON.parse(rawPayload) : rawPayload;
    } catch (e) {
      const errObj = {
        category: ErrorCategory.WEBSOCKET,
        code: 'INVALID_JSON',
        message: 'Invalid JSON received from server',
        details: e,
        timestamp: new Date().toISOString(),
      };
      this._emitError(errObj);
      return;
    }

    const isEnvelope = parsed && parsed.headers && parsed.payload;
    const isError = parsed?.state === 'error' || parsed?.actionType === 'error' || !!parsed?.error;

    // Optional inbound validation (envelope) when strictValidation enabled
    if (this.options.strictValidation && isEnvelope) {
      const vr = this._validateMessageEnvelope(parsed);
      if (!vr.valid) {
        this.handleError(
          ErrorCategory.VALIDATION,
          'INBOUND_ENVELOPE_SCHEMA_MISMATCH',
          this.formatValidationErrorMessage(vr.errors, 'Inbound envelope validation failed'),
          vr.errors
        );
      }
    }

    if (isError) {
      const correlationId =
        (parsed?.headers && parsed.headers.correlationId) || parsed?.correlationId || null;
      const errObj = {
        category: ErrorCategory.ORCHESTRATOR,
        code: parsed?.error?.code || 'REMOTE_ERROR',
        message: parsed?.error?.message || parsed?.message || 'Remote error',
        details: parsed?.error || parsed,
        correlationId,
      };
      // Correlation rejection path
      if (correlationId && this._pending.has(correlationId)) {
        const entry = this._pending.get(correlationId);
        if (entry.timer) {
          clearTimeout(entry.timer);
        }
        entry._handled = true; // Mark as handled
        this._pending.delete(correlationId);
        entry.reject(errObj);
      }
      this._emitError(errObj, parsed?.action);
      return;
    }

    // Correlation fulfillment (success)
    const correlationId = parsed?.headers?.correlationId || parsed?.correlationId;
    if (correlationId && this._pending.has(correlationId)) {
      const entry = this._pending.get(correlationId);
      if (entry.timer) {
        clearTimeout(entry.timer);
      }
      entry._handled = true; // Mark as handled
      this._pending.delete(correlationId);
      entry.resolve(parsed);
    }

    // Legacy emission (unchanged)
    this.emit(LegacyEvents.MESSAGE, parsed);

    // One-time deprecation warning for legacy 'message'
    if (!warnedMessageEventOnce) {
      warnedMessageEventOnce = true;
      (this.options?.logger?.warn || console.warn)(
        '[optave-sdk][deprecation] The "message" event will be deprecated. Please also listen to "superpower.response".'
      );
    }

    // New event (same payload as legacy message)
    this.emit(InboundEvents.SUPERPOWER_RESPONSE, parsed);

    // New canonical response event (parsed object) - keeping existing behavior
    this.emit(EVENTS.RESPONSE, parsed);

    // Per-action convenience (lowercased) - keeping existing behavior
    if (parsed?.action) {
      this.emit(`message.${parsed.action}`.toLowerCase(), parsed);
    }

    // Preserve prior schemaRef emission for envelopes - keeping existing behavior
    if (isEnvelope && parsed.headers.schemaRef) {
      this.emit(parsed.headers.schemaRef, parsed);
    }
  }

  _emitError(errObj, action = null) {
    if (!errObj.timestamp) {
      errObj.timestamp = new Date().toISOString();
    }

    // Legacy emission (unchanged) - keep emitting structured objects
    this.emit(LegacyEvents.ERROR, errObj);

    // One-time deprecation warning for legacy error events:
    if (!warnedErrorStringOnce) {
      warnedErrorStringOnce = true;
      (this.options?.logger?.warn || console.warn)(
        '[optave-sdk][deprecation] The "error" (string payload) is deprecated. Please also listen to "superpower.error" for a structured error object.'
      );
    }

    // New event: structured Error object (non-breaking because it's a new event name)
    const structuredError = makeStructuredError(errObj);
    this.emit(InboundEvents.SUPERPOWER_ERROR, structuredError);

    // Keep existing behavior for EVENTS.ERROR
    this.emit(EVENTS.ERROR, errObj);
  }

  closeConnection() {
    if (this.wss) {
      // Clear all WebSocket event handlers to break circular references
      this.wss.onopen = null;
      this.wss.onmessage = null;
      this.wss.onclose = null;
      this.wss.onerror = null;

      this.wss.close();
      this.wss = null;
    }
  }

  selectiveDeepMerge(target, source) {
    if (Array.isArray(target) && Array.isArray(source)) {
      // If both target and source are arrays, replace target with source
      return [...source];
    }

    // Use more reliable object detection that works across webpack contexts
    const isObject = obj => obj !== null && typeof obj === 'object' && !Array.isArray(obj);

    if (isObject(target) && isObject(source)) {
      const result = { ...target }; // Start with all target keys
      // Process all source keys, merging or overriding
      for (let key in source) {
        if (key in target) {
          // Recursively merge or replace values
          result[key] = this.selectiveDeepMerge(target[key], source[key]);
        } else {
          // Add new keys from source that don't exist in target
          result[key] = source[key];
        }
      }
      return result;
    }

    // For primitive values, return source value if it exists, else fallback to target
    return source !== undefined ? source : target;
  }

  isPayloadSizeValid(payloadString) {
    if (!payloadString) {
      return false;
    }

    // Check if the size is within the limit
    return payloadString.length / 1024 <= CONSTANTS.MAX_PAYLOAD_SIZE_KB;
  }

  openConnectionAsync(bearerToken) {
    return new Promise((resolve, reject) => {
      const onOpen = e => {
        this.off('error', onErr);
        resolve(e);
      };
      const onErr = e => {
        this.off('open', onOpen);
        reject(e);
      };
      this.once('open', onOpen);
      this.once('error', onErr);
      this.openConnection(bearerToken);
    });
  }

  buildPayload(requestType, action, params) {
    let payload = this.selectiveDeepMerge(OptaveJavaScriptSDK.defaultPayload, params);
    // Legacy alias mapping (variation -> variant) with deprecation notice
    if (params?.request?.variation) {
      this.deprecate(
        'payload.request.variation',
        "[Deprecation] 'request.variation' is deprecated; use 'request.attributes.variant'."
      );
      payload.request.attributes.variant = params.request.variation;
    }
    // Legacy mapping: move request.content to attributes.content if provided at old location
    if (params?.request?.content && !payload.request?.attributes?.content) {
      payload.request.attributes.content = params.request.content;
      this.deprecate(
        'payload.request.content',
        "[Deprecation] 'request.content' is deprecated; use 'request.attributes.content'."
      );
    }

    // Ensure variant is properly set and uppercase
    if (payload.request.attributes.variant) {
      payload.request.attributes.variant = payload.request.attributes.variant.toUpperCase();
    }
    return payload;
  }

  // Maps action and request type to standardized AsyncAPI message ID
  resolveMessageId(requestType, action) {
    return `${action}.${requestType}.v3`.toLowerCase(); // e.g., "adjust.message.v3"
  }

  // Wraps payload in message envelope with headers for tracking and versioning (supports overrides)
  buildMessageEnvelope(payload, requestType, action, headerOverrides = {}) {
    const now = new Date().toISOString();
    const correlationId = headerOverrides.correlationId || payload?.request?.requestId || uuidv7();
    const traceId = headerOverrides.traceId || uuidv7();
    const idempotencyKey = headerOverrides.idempotencyKey || uuidv7();
    const timestamp = headerOverrides.timestamp; // user event time (overrideable)
    const issuedAt = now; // envelope build time

    const headers = {
      correlationId,
      action,
      schemaRef: SCHEMA_REF,
      sdkVersion: SDK_VERSION,
      identifier: requestType,
      traceId,
      idempotencyKey,
      timestamp,
      issuedAt,
    };
    if (this.options.tenantId) {
      headers.tenantId = this.options.tenantId;
    }
    if (headerOverrides.networkLatencyMs !== undefined) {
      headers.networkLatencyMs = headerOverrides.networkLatencyMs;
    }
    // Freeze headers to prevent accidental mutation after envelope construction.
    // (Shallow freeze is enough because all current header values are primitives.)
    Object.freeze(headers);
    return {
      action: 'message',
      headers,
      payload,
    };
  }

  formatValidationErrorMessage(errors, baseMessage = 'Validation failed') {
    if (!errors || !Array.isArray(errors) || errors.length === 0) {
      return baseMessage;
    }

    // If there's only one error, provide a detailed explanation
    if (errors.length === 1) {
      const error = errors[0];
      const fieldPath = error.instancePath || '/';
      const field =
        fieldPath === '/' ? 'root object' : fieldPath.replace(/^\//, '').replace(/\//g, '.');

      if (error.keyword === 'required') {
        const missingField = error.params?.missingProperty || 'unknown field';
        // Handle case where instancePath already points to the missing property
        const fullFieldPath =
          field === 'root object'
            ? missingField
            : field.endsWith(missingField)
            ? field
            : field + '.' + missingField;
        return `${baseMessage}: ${
          field === 'root object' ? 'Required field' : 'Field'
        } '${fullFieldPath}' is missing`;
      } else if (error.keyword === 'type') {
        const expectedType = error.params?.type || 'unknown';
        return `${baseMessage}: Field '${field}' must be of type '${expectedType}'`;
      } else if (error.keyword === 'additionalProperties') {
        const additionalProp = error.params?.additionalProperty || 'unknown';
        return `${baseMessage}: Field '${field}.${additionalProp}' is not allowed`;
      } else if (error.keyword === 'enum') {
        const allowedValues = error.params?.allowedValues || [];
        const allowedStr = Array.isArray(allowedValues)
          ? allowedValues.join(', ')
          : 'unknown values';
        return `${baseMessage}: Field '${field}' must be one of: ${allowedStr}`;
      } else {
        return `${baseMessage}: ${error.message} at '${field}'`;
      }
    }

    // If there are multiple errors, provide a summary with the most critical ones
    const criticalErrors = errors.filter(e => e.keyword === 'required');
    const typeErrors = errors.filter(e => e.keyword === 'type');
    const otherErrors = errors.filter(e => e.keyword !== 'required' && e.keyword !== 'type');

    let summary = baseMessage + ':';

    if (criticalErrors.length > 0) {
      const missingFields = criticalErrors.map(e => {
        const field = (e.instancePath || '/').replace(/^\//, '').replace(/\//g, '.');
        const missing = e.params?.missingProperty || 'unknown';
        return field === '' ? missing : `${field}.${missing}`;
      });
      summary += ` Missing required fields: ${missingFields.join(', ')}.`;
    }

    if (typeErrors.length > 0) {
      const typeIssues = typeErrors.slice(0, 3).map(e => {
        const field = (e.instancePath || '/').replace(/^\//, '').replace(/\//g, '.');
        const expectedType = e.params?.type || 'unknown';
        return `${field || 'root'} (expected ${expectedType})`;
      });
      summary += ` Type errors in: ${typeIssues.join(', ')}.`;
      if (typeErrors.length > 3) summary += ` And ${typeErrors.length - 3} more type errors.`;
    }

    if (otherErrors.length > 0) {
      summary += ` Additional validation errors: ${otherErrors.length}.`;
    }

    return summary;
  }

  formatAuthenticationError(response, serverError, context) {
    let message = 'Authentication failed';
    const suggestions = [];

    // Include HTTP status if available
    if (response && response.status) {
      message += ` (HTTP ${response.status})`;
    }

    // Add server error details
    if (serverError) {
      if (typeof serverError === 'string') {
        message += `: ${serverError}`;
      } else if (serverError.error_description) {
        message += `: ${serverError.error_description}`;
      } else if (serverError.message) {
        message += `: ${serverError.message}`;
      } else if (serverError.error) {
        message += `: ${serverError.error}`;
      }
    }

    // Add context-specific suggestions
    if (response && response.status === 401) {
      suggestions.push('Verify clientId and clientSecret are correct');
      suggestions.push('Ensure credentials match the target environment (dev/staging/production)');
    } else if (response && response.status === 403) {
      suggestions.push('Check if your client has the necessary permissions');
      suggestions.push('Verify the authentication endpoint URL is correct');
    } else if (response && response.status >= 500) {
      suggestions.push('Authentication server error - try again later');
      suggestions.push('Contact support if the problem persists');
    } else {
      suggestions.push('Check network connectivity and authentication endpoint configuration');
    }

    // Add environment context if available
    if (context && context.authUrl) {
      message += ` (endpoint: ${context.authUrl})`;
    }

    return { message, suggestions };
  }

  formatWebSocketError(errorEvent, context) {
    let message = 'WebSocket connection failed';
    const suggestions = [];

    // Extract error details from different event types
    const errorMessage =
      errorEvent?.message ||
      (errorEvent instanceof Error ? errorEvent.message : null) ||
      (typeof errorEvent === 'object' && errorEvent.error && errorEvent.error.message) ||
      null;

    if (errorMessage) {
      message += `: ${errorMessage}`;
    }

    // Add connection context
    if (context) {
      if (context.url) {
        message += ` (URL: ${context.url})`;
      }
      if (context.timeout) {
        message += ` (timeout: ${context.timeout}ms)`;
      }
    }

    // Provide troubleshooting suggestions
    suggestions.push('Check network connectivity and firewall settings');
    suggestions.push('Verify WebSocket URL is correct and accessible');

    if (context && context.url) {
      if (context.url.startsWith('ws://')) {
        suggestions.push('Consider using secure WebSocket (wss://) for production');
      }
      if (context.url.includes('localhost') || context.url.includes('127.0.0.1')) {
        suggestions.push('Ensure local server is running if connecting to localhost');
      }
    }

    if (context && context.timeout) {
      suggestions.push('Try increasing connection timeout if network is slow');
    }

    return { message, suggestions };
  }

  formatPayloadSizeError(actualSize, maxSize, payload) {
    const actualKB = Math.ceil(actualSize / 1024);
    const maxKB = maxSize;
    const overageKB = actualKB - maxKB;

    let message = `Payload too large: ${actualKB}KB exceeds maximum ${maxKB}KB (${overageKB}KB over limit)`;
    const suggestions = [];

    // Analyze payload for optimization suggestions
    if (payload && typeof payload === 'object') {
      const payloadStr = JSON.stringify(payload);

      // Check for large conversation arrays
      if (
        payload.request?.scope?.conversations &&
        Array.isArray(payload.request.scope.conversations)
      ) {
        const conversationsSize = JSON.stringify(payload.request.scope.conversations).length;
        const conversationsKB = Math.ceil(conversationsSize / 1024);
        if (conversationsKB > 10) {
          // If conversations are more than 10KB
          suggestions.push(
            `Consider reducing conversation history - current size: ~${conversationsKB}KB`
          );
          suggestions.push('Remove older messages or summarize conversation context');
        }
      }

      // Check for large offers arrays
      if (payload.request?.resources?.offers && Array.isArray(payload.request.resources.offers)) {
        const offersSize = JSON.stringify(payload.request.resources.offers).length;
        const offersKB = Math.ceil(offersSize / 1024);
        if (offersKB > 5) {
          suggestions.push(`Consider reducing product offers data - current size: ~${offersKB}KB`);
        }
      }

      // Check for large metadata
      if (payload.session?.channel?.metadata && Array.isArray(payload.session.channel.metadata)) {
        const metadataSize = JSON.stringify(payload.session.channel.metadata).length;
        const metadataKB = Math.ceil(metadataSize / 1024);
        if (metadataKB > 2) {
          suggestions.push(`Consider reducing metadata array - current size: ~${metadataKB}KB`);
        }
      }
    }

    // General suggestions if no specific optimizations found
    if (suggestions.length === 0) {
      suggestions.push('Remove unused fields from request payload');
      suggestions.push('Consider paginating large datasets');
      suggestions.push('Use shorter field values where possible');
    }

    return { message, suggestions };
  }

  formatTokenProviderError(originalError, context) {
    let message = 'Failed to obtain WebSocket token from tokenProvider()';
    const suggestions = [];

    // Add original error details
    if (originalError) {
      if (originalError.message) {
        message += `: ${originalError.message}`;
      } else if (typeof originalError === 'string') {
        message += `: ${originalError}`;
      }

      // Analyze error type for specific suggestions
      if (originalError.name === 'TypeError' && originalError.message?.includes('fetch')) {
        suggestions.push('Check if tokenProvider endpoint is accessible');
        suggestions.push('Verify CORS settings allow requests to token endpoint');
      } else if (
        originalError.message?.includes('404') ||
        originalError.message?.includes('Not Found')
      ) {
        suggestions.push('Verify tokenProvider endpoint URL is correct');
        suggestions.push('Ensure backend token endpoint is implemented');
      } else if (originalError.message?.includes('401') || originalError.message?.includes('403')) {
        suggestions.push('Check authentication/authorization for token endpoint');
        suggestions.push('Verify user session or credentials are valid');
      } else if (originalError.message?.includes('timeout')) {
        suggestions.push(
          'Token provider request timed out - check network or server response time'
        );
      }
    }

    // Add context-specific guidance
    if (context && context.tokenUrl) {
      message += ` (endpoint: ${context.tokenUrl})`;
    }

    // General troubleshooting suggestions
    if (suggestions.length === 0) {
      suggestions.push('Verify tokenProvider function implementation');
      suggestions.push('Check backend token endpoint is running and accessible');
      suggestions.push('Review browser console for network errors');
    }

    return { message, suggestions };
  }

  handleError(category, code, message, details = null, suggestions = [], correlationId = null) {
    const errObj = new OptaveError({ category, code, message, details });
    if (suggestions) errObj.suggestions = suggestions;
    if (correlationId) errObj.correlationId = correlationId;
    if (this.listenerCount(LegacyEvents.ERROR) === 0 && this.listenerCount(EVENTS.ERROR) === 0) {
      (this.options?.logger?.error || console.error)(`[Optave SDK] ${code}: ${message}`);
    }
    this._emitError(errObj);
  }

  send(requestType, action, params) {
    const OPEN =
      (this.WebSocketImpl && this.WebSocketImpl.OPEN) != null ? this.WebSocketImpl.OPEN : 1;
    if (!(this.wss && this.wss.readyState === OPEN)) {
      const readyState = this.wss ? this.wss.readyState : 'no connection';
      this.handleError(
        ErrorCategory.WEBSOCKET,
        'WEBSOCKET_NOT_IN_OPEN_STATE',
        this.formatWebSocketError(new Error('WebSocket not ready for sending'), {
          readyState,
          action,
        }).message
      );
      return;
    }
    if (!ALLOWED_ACTIONS.has(action)) {
      this.handleError(
        ErrorCategory.VALIDATION,
        'INVALID_ACTION',
        `Unsupported action '${action}'. Allowed: ${[...ALLOWED_ACTIONS].join(', ')}`
      );
      return;
    }

    // Lightweight additional-property detection BEFORE merge (top-level only)
    const allowedTopLevel = new Set(['session', 'request', 'headers']);
    for (const k of Object.keys(params || {})) {
      if (!allowedTopLevel.has(k)) {
        const errors = [
          {
            instancePath: '',
            keyword: 'additionalProperties',
            params: { additionalProperty: k },
            message: `must NOT have additional property '${k}'`,
          },
        ];
        this.handleError(
          ErrorCategory.VALIDATION,
          'PAYLOAD_SCHEMA_MISMATCH',
          this.formatValidationErrorMessage(errors),
          errors
        );
        return;
      }
    }

    // Build merged payload first so defaults satisfy required properties
    const payload = this.buildPayload(requestType, action, params || {});

    // Validate required fields on merged payload FIRST (more specific error)
    const requiredFieldValidation = this.validateRequiredFields(payload || {}, action);
    if (!requiredFieldValidation.isValid) {
      this.handleError(
        ErrorCategory.VALIDATION,
        'REQUIRED_FIELDS_MISSING',
        `Missing required fields for action '${action}': ${requiredFieldValidation.errors.join(
          ', '
        )}`,
        requiredFieldValidation.errors
      );
      return;
    }

    // Then do full schema validation if enabled
    if (this.options.strictValidation) {
      const schemaResult = this._validatePayload(payload);
      if (!schemaResult.valid) {
        this.handleError(
          ErrorCategory.VALIDATION,
          'PAYLOAD_SCHEMA_MISMATCH',
          this.formatValidationErrorMessage(schemaResult.errors, 'Schema validation failed'),
          schemaResult.errors
        );
        return;
      }
    }

    const envelope = this.buildMessageEnvelope(payload, requestType, action, params?.headers || {});
    const payloadString = JSON.stringify(envelope);

    if (!this.isPayloadSizeValid(payloadString)) {
      const actualSize = payloadString.length; // Size in bytes
      this.handleError(
        ErrorCategory.VALIDATION,
        'PAYLOAD_TOO_LARGE',
        this.formatPayloadSizeError(actualSize, CONSTANTS.MAX_PAYLOAD_SIZE_KB, envelope).message,
        CONSTANTS.MAX_PAYLOAD_SIZE_KB
      );
      return;
    }
    this.wss.send(payloadString);
  }

  // The following functions send messages of a specific type to the WebSocket
  adjust(params) {
    return this.send('message', 'adjust', params);
  }
  elevate(params) {
    return this.send('message', 'elevate', params);
  }
  interaction(params) {
    return this.send('message', 'interaction', params);
  }
  reception(params) {
    return this.send('message', 'reception', params);
  }
  // Deprecated alias (will be removed in a future major version)
  customerInteraction(params) {
    this.deprecate(
      'method.customerInteraction',
      "[Deprecation] 'customerInteraction' is deprecated; use 'interaction' instead."
    );
    return this.send('message', 'customerInteraction', params);
  }
  summarize(params) {
    return this.send('message', 'summarize', params);
  }
  translate(params) {
    return this.send('message', 'translate', params);
  }
  recommend(params) {
    return this.send('message', 'recommend', params);
  }
  insights(params) {
    return this.send('message', 'insights', params);
  }

  // ----- Promise-based Request API -----
  _registerPending(correlationId, action, timeoutMs, resolve, reject) {
    let timer = null;

    // Only set up timeout if timeoutMs is greater than 0
    if (timeoutMs > 0) {
      timer = setTimeout(() => {
        // Double-check that the promise hasn't been resolved/rejected by WebSocket events
        if (this._pending.has(correlationId)) {
          const entry = this._pending.get(correlationId);
          // Only proceed if this entry hasn't been handled by WebSocket events
          if (entry && !entry._handled) {
            this._pending.delete(correlationId);
            entry._handled = true; // Mark as handled
            reject({
              category: ErrorCategory.WEBSOCKET,
              code: 'REQUEST_TIMEOUT',
              message: `Request timed out after ${timeoutMs}ms`,
              details: { correlationId, action },
              correlationId,
            });
          }
        }
      }, timeoutMs);
    }

    this._pending.set(correlationId, { resolve, reject, timer, action, _handled: false });
  }

  _promiseSend(requestType, action, params = {}, opts = {}) {
    let correlationId; // Declare outside promise to access later
    let promiseResolve, promiseReject; // Capture for timeout registration

    const promise = new Promise((resolve, reject) => {
      promiseResolve = resolve;
      promiseReject = reject;

      // Calculate timeout duration early to determine behavior
      const timeoutMs =
        typeof opts.timeoutMs === 'number'
          ? opts.timeoutMs
          : typeof opts.timeout === 'number'
          ? opts.timeout
          : this.options.requestTimeoutMs;

      if (!this.wss || this.wss.readyState !== WebSocket.OPEN) {
        // If no timeout is specified, fail immediately with WebSocket state error
        if (timeoutMs <= 0) {
          reject({
            category: ErrorCategory.WEBSOCKET,
            code: 'WEBSOCKET_NOT_IN_OPEN_STATE',
            message: 'WebSocket not open',
            details: null,
          });
          return;
        }
        // Otherwise, let the timeout mechanism handle the failure
        // Generate correlationId for timeout tracking even when WebSocket is closed
        // Build minimal payload for correlationId generation
        const payload = this.buildPayload(requestType, action, params);
        const envelope = this.buildMessageEnvelope(
          payload,
          requestType,
          action,
          params?.headers || {}
        );
        correlationId = envelope.headers.correlationId;
        this._registerPending(correlationId, action, timeoutMs, resolve, reject);
        return; // Let timeout handle the rejection
      }
      if (!ALLOWED_ACTIONS.has(action)) {
        reject({
          category: ErrorCategory.VALIDATION,
          code: 'INVALID_ACTION',
          message: `Unsupported action '${action}'.`,
          details: { allowed: [...ALLOWED_ACTIONS] },
        });
        return;
      }
      // Additional property check (top-level) mirroring send()
      const allowedTopLevel = new Set(['session', 'request', 'headers']);
      for (const k of Object.keys(params || {})) {
        if (!allowedTopLevel.has(k)) {
          const errors = [
            {
              instancePath: '',
              keyword: 'additionalProperties',
              params: { additionalProperty: k },
              message: `must NOT have additional property '${k}'`,
            },
          ];
          reject({
            category: ErrorCategory.VALIDATION,
            code: 'PAYLOAD_SCHEMA_MISMATCH',
            message: this.formatValidationErrorMessage(errors),
            details: errors,
          });
          return;
        }
      }
      const payload = this.buildPayload(requestType, action, params);

      // Validate required fields FIRST (more specific error)
      const requiredFieldValidation = this.validateRequiredFields(payload, action);
      if (!requiredFieldValidation.isValid) {
        reject({
          category: ErrorCategory.VALIDATION,
          code: 'REQUIRED_FIELDS_MISSING',
          message: `Missing required fields for action '${action}'`,
          details: requiredFieldValidation.errors,
        });
        return;
      }

      // Then do full schema validation if enabled
      if (this.options.strictValidation) {
        const schemaResult = validateGeneratedPayload(payload);
        if (!schemaResult.valid) {
          reject({
            category: ErrorCategory.VALIDATION,
            code: 'PAYLOAD_SCHEMA_MISMATCH',
            message: this.formatValidationErrorMessage(
              schemaResult.errors,
              'Schema validation failed'
            ),
            details: schemaResult.errors,
          });
          return;
        }
      }
      const envelope = this.buildMessageEnvelope(
        payload,
        requestType,
        action,
        params?.headers || {}
      );
      correlationId = envelope.headers.correlationId; // Assign to outer scope variable

      // Register timeout for normal WebSocket flow
      this._registerPending(correlationId, action, timeoutMs, resolve, reject);

      const payloadString = JSON.stringify(envelope);
      if (!this.isPayloadSizeValid(payloadString)) {
        const actualSize = payloadString.length; // Size in bytes
        const errorMessage = this.formatPayloadSizeError(
          actualSize,
          CONSTANTS.MAX_PAYLOAD_SIZE_KB,
          envelope
        ).message;
        reject({
          category: ErrorCategory.VALIDATION,
          code: 'PAYLOAD_TOO_LARGE',
          message: errorMessage,
          details: { maxKb: CONSTANTS.MAX_PAYLOAD_SIZE_KB },
        });
        return;
      }

      try {
        this.wss.send(payloadString);
      } catch (e) {
        if (this._pending.has(correlationId)) {
          const entry = this._pending.get(correlationId);
          // Clear timer if it exists
          if (entry.timer) {
            clearTimeout(entry.timer);
          }
          // Mark as handled to prevent timeout from firing
          entry._handled = true;
          this._pending.delete(correlationId);
        }
        reject({
          category: ErrorCategory.WEBSOCKET,
          code: 'SEND_FAILED',
          message: 'Failed to send over WebSocket',
          details: e,
          correlationId,
        });
      }
    });

    // Attach correlationId to the promise for external access
    promise.correlationId = correlationId;

    return promise;
  }

  // Promise-based helpers (suffix Async)
  adjustAsync(params, opts) {
    return this._promiseSend('message', 'adjust', params, opts);
  }
  elevateAsync(params, opts) {
    return this._promiseSend('message', 'elevate', params, opts);
  }
  interactionAsync(params, opts) {
    return this._promiseSend('message', 'interaction', params, opts);
  }
  receptionAsync(params, opts) {
    return this._promiseSend('message', 'reception', params, opts);
  }
  // Deprecated alias
  customerInteractionAsync(params, opts) {
    this.deprecate(
      'method.customerInteractionAsync',
      "[Deprecation] 'customerInteractionAsync' is deprecated; use 'interactionAsync' instead."
    );
    return this._promiseSend('message', 'customerInteraction', params, opts);
  }
  summarizeAsync(params, opts) {
    return this._promiseSend('message', 'summarize', params, opts);
  }
  translateAsync(params, opts) {
    return this._promiseSend('message', 'translate', params, opts);
  }
  recommendAsync(params, opts) {
    return this._promiseSend('message', 'recommend', params, opts);
  }
  insightsAsync(params, opts) {
    return this._promiseSend('message', 'insights', params, opts);
  }

  cancelRequest(correlationId) {
    if (this._pending.has(correlationId)) {
      const entry = this._pending.get(correlationId);
      // Clear timer if it exists
      if (entry.timer) {
        clearTimeout(entry.timer);
      }
      // Mark as handled to prevent timeout from firing
      entry._handled = true;
      this._pending.delete(correlationId);

      // Use setTimeout to allow any existing .catch() handlers to be attached
      setTimeout(() => {
        entry.reject({
          category: ErrorCategory.WEBSOCKET,
          code: 'REQUEST_CANCELLED',
          message: 'Request was cancelled',
          details: { correlationId },
          correlationId,
        });
      }, 0);

      return true;
    }
    return false;
  }

  cancelPendingRequests(isCleaningUp = false) {
    // Defensive check: if cleanup() has already been called, _pending will be null
    if (!this._pending) {
      return 0;
    }

    const cancelledCount = this._pending.size;
    const entries = [...this._pending.entries()]; // Copy to avoid modification during iteration

    for (const [correlationId, entry] of entries) {
      // Clear timer if it exists
      if (entry.timer) {
        clearTimeout(entry.timer);
      }
      // Mark as handled to prevent timeout from firing
      entry._handled = true;

      if (isCleaningUp) {
        // During cleanup, reject immediately to prevent memory leaks from setTimeout
        entry.reject({
          category: ErrorCategory.WEBSOCKET,
          code: 'REQUEST_CANCELLED',
          message: 'Request was cancelled during cleanup',
          details: { correlationId },
          correlationId,
        });
      } else {
        // Use queueMicrotask to allow any existing .catch() handlers to be attached
        // This is more appropriate than setTimeout(0) and doesn't depend on DOM context
        // eliminating the JSDOM window closure issue in UMD builds
        queueMicrotask(() => {
          entry.reject({
            category: ErrorCategory.WEBSOCKET,
            code: 'REQUEST_CANCELLED',
            message: 'Request was cancelled',
            details: { correlationId },
            correlationId,
          });
        });
      }
    }
    this._pending.clear();
    return cancelledCount;
  }

  /**
   * Comprehensive cleanup method to prevent memory leaks
   * Cleans up all internal state including Maps, Sets, and WebSocket connections
   */
  cleanup() {
    // Close WebSocket connection first to break external references
    this.closeConnection();

    // Cancel all pending requests and clear timers
    // Pass isCleaningUp=true to avoid creating new timeouts during cleanup
    this.cancelPendingRequests(true);

    // Note: No timeout cleanup needed since we use queueMicrotask() instead of setTimeout()
    // queueMicrotask() doesn't require manual cleanup as it doesn't hold references

    // Clear internal data structures
    if (this._deprecatedKeys) {
      this._deprecatedKeys.clear();
    }

    // Clear any warning flags (instance-specific)
    if (this._warnedQueryToken !== undefined) {
      delete this._warnedQueryToken;
    }

    // CRITICAL: Clear EventEmitter state BEFORE calling removeAllListeners
    // This prevents the complex removeAllListeners override from interfering
    if (this._events) {
      // Manually clear each event to break listener references
      for (const event in this._events) {
        delete this._events[event];
      }
    }

    // Now remove all listeners (this should be mostly a no-op after manual cleanup)
    this.removeAllListeners();

    // CRITICAL: Set EventEmitter properties to null AFTER removeAllListeners
    // This ensures complete cleanup before breaking prototype chain
    this._events = null;
    this._eventsCount = null;
    this._maxListeners = null;

    // CRITICAL: Clean up JSDOM contexts created by SDK loader
    // UMD builds loaded through test infrastructure create JSDOM environments
    // that must be explicitly closed to prevent memory leaks
    // Only run in non-server builds to avoid window references in server.mjs
    const buildTarget = typeof __WEBPACK_BUILD_TARGET__ !== 'undefined' ? __WEBPACK_BUILD_TARGET__ : 'unknown';
    if (buildTarget !== 'server-esm' && buildTarget !== 'server-umd') {
      if (this.constructor._preservedJSDOM && this.constructor._preservedJSDOM.dom) {
        try {
          // Access window through dom property to minimize direct window references
          const domWindow = this.constructor._preservedJSDOM.dom.window;
          if (domWindow && typeof domWindow.close === 'function') {
            domWindow.close();
          }
          delete this.constructor._preservedJSDOM;
        } catch (e) {
          // Ignore errors if JSDOM is already closed
        }
      }
    }

    // Clear function references that might hold closures
    this._validatePayload = null;
    this._validateMessageEnvelope = null;
    this._emitError = null;
    this._ensureWebSocketImpl = null;
    this._handleInbound = null;
    this._promiseSend = null;
    this._registerPending = null;
    this._warnOnce = null;

    // Clear object references completely
    this.options = null;
    this.WebSocketImpl = null;
    this.wss = null;
    this.sessionId = null;

    // Clear collections with explicit null assignment
    this._pending = null;
    this._deprecatedKeys = null;

    // Clear primitive flags
    this._silenceDeprecations = null;

    // FINAL: Ensure EventEmitter properties are definitively null after all cleanup
    // This must be LAST to override any potential resets from removeAllListeners
    this._events = null;
    this._eventsCount = null;
    this._maxListeners = null;
  }

  /**
   * Override removeAllListeners to include internal cleanup
   * Simplified to avoid complex fallback logic that might interfere with GC
   */
  removeAllListeners(event) {
    // Try the parent EventEmitter method
    try {
      EventEmitter.prototype.removeAllListeners.call(this, event);
    } catch (e) {
      // Fallback: manual cleanup if parent method fails
      if (!event) {
        this._events = Object.create(null);
        this._eventsCount = 0;
      } else if (this._events && this._events[event]) {
        delete this._events[event];
        this._eventsCount = Math.max(0, this._eventsCount - 1);
      }
    }

    return this;
  }

  // Static properties for build configuration flags (used by webpack DefinePlugin)
  static get buildFlags() {
    const buildTarget =
      typeof __WEBPACK_BUILD_TARGET__ !== 'undefined' ? __WEBPACK_BUILD_TARGET__ : 'unknown';

    return {
      SALESFORCE_BUILD: typeof __SALESFORCE_BUILD__ !== 'undefined' ? __SALESFORCE_BUILD__ : false,
      INCLUDE_WS_REQUIRE:
        typeof __INCLUDE_WS_REQUIRE__ !== 'undefined' ? __INCLUDE_WS_REQUIRE__ : true,
      SDK_VERSION: typeof __SDK_VERSION__ !== 'undefined' ? __SDK_VERSION__ : '0.0.0-dev',
      WEBPACK_BUILD_TARGET: buildTarget,
      WEBPACK_BUILD_TARGET_NORMALIZED: BuildTargetUtils.normalize(buildTarget),
      BUILD_TARGET_INFO: BuildTargetUtils.getInfo(buildTarget),
    };
  }
}

// Export as both named and default to work with UMD without getter patterns
// UMD builds: globalThis.OptaveJavaScriptSDK (via default export)
// ESM builds: import { OptaveJavaScriptSDK } from '@optave/client-sdk'
export { OptaveJavaScriptSDK };
export default OptaveJavaScriptSDK;
